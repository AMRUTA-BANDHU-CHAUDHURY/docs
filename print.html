<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes CSI Developer Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This site documents how to develop and deploy a Container Storage Interface (CSI) driver on Kubernetes.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="developing.html"><strong aria-hidden="true">2.</strong> Developing a CSI Driver for Kubernetes</a></li><li><ol class="section"><li><a href="sidecar-containers.html"><strong aria-hidden="true">2.1.</strong> Sidecar Containers</a></li><li><ol class="section"><li><a href="external-provisioner.html"><strong aria-hidden="true">2.1.1.</strong> external-provisioner</a></li><li><a href="external-attacher.html"><strong aria-hidden="true">2.1.2.</strong> external-attacher</a></li><li><a href="external-snapshotter.html"><strong aria-hidden="true">2.1.3.</strong> external-snapshotter</a></li><li><a href="node-driver-registrar.html"><strong aria-hidden="true">2.1.4.</strong> node-driver-registrar</a></li><li><a href="cluster-driver-registrar.html"><strong aria-hidden="true">2.1.5.</strong> cluster-driver-registrar</a></li><li><a href="livenessprobe.html"><strong aria-hidden="true">2.1.6.</strong> livenessprobe</a></li></ol></li><li><a href="csi-crds.html"><strong aria-hidden="true">2.2.</strong> CSI CRDs</a></li><li><ol class="section"><li><a href="csi-driver-object.html"><strong aria-hidden="true">2.2.1.</strong> CSIDriver Object</a></li><li><a href="csi-node-info-object.html"><strong aria-hidden="true">2.2.2.</strong> CSINodeInfo Object</a></li></ol></li><li><a href="features.html"><strong aria-hidden="true">2.3.</strong> Features</a></li><li><ol class="section"><li><a href="secrets-and-credentials.html"><strong aria-hidden="true">2.3.1.</strong> Secrets &amp; Credentials</a></li><li><a href="snapshot-restore-feature.html"><strong aria-hidden="true">2.3.2.</strong> Volume Snapshot &amp; Restore</a></li><li><a href="topology.html"><strong aria-hidden="true">2.3.3.</strong> Topology</a></li><li><a href="raw-block.html"><strong aria-hidden="true">2.3.4.</strong> Raw Block Volume</a></li><li><a href="skip-attach.html"><strong aria-hidden="true">2.3.5.</strong> Skip Attach</a></li><li><a href="pod-info.html"><strong aria-hidden="true">2.3.6.</strong> Pod Info on Mount</a></li><li><a href="ephemeral-local-volumes.html"><strong aria-hidden="true">2.3.7.</strong> Ephemeral Local Volumes</a></li></ol></li></ol></li><li><a href="deploying.html"><strong aria-hidden="true">3.</strong> Deploying a CSI Driver on Kubernetes</a></li><li><ol class="section"><li><a href="example.html"><strong aria-hidden="true">3.1.</strong> Example</a></li></ol></li><li><a href="testing-drivers.html"><strong aria-hidden="true">4.</strong> Driver Testing</a></li><li><ol class="section"><li><a href="unit-testing.html"><strong aria-hidden="true">4.1.</strong> Unit Testing</a></li><li><a href="functional-testing.html"><strong aria-hidden="true">4.2.</strong> Functional Testing</a></li></ol></li><li><a href="drivers.html"><strong aria-hidden="true">5.</strong> Drivers</a></li><li><a href="troubleshooting.html"><strong aria-hidden="true">6.</strong> Troubleshooting</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Kubernetes CSI Developer Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#kubernetes-container-storage-interface-csi-documentation" id="kubernetes-container-storage-interface-csi-documentation"><h2>Kubernetes Container Storage Interface (CSI) Documentation</h2></a>
<p>This site documents how to develop, deploy, and test a <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) driver on Kubernetes.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) is a standard for exposing arbitrary block and file storage storage systems to containerized workloads on Container Orchestration Systems (COs) like Kubernetes. Using CSI third-party storage providers can write and deploy plugins exposing new storage systems in Kubernetes without ever having to touch the core Kubernetes code.</p>
<p>The target audience for this site is third-party developers interested in developing CSI drivers for Kubernetes.</p>
<p>Kubernetes users interested in how to deploy or manage an existing CSI driver on Kubernetes should look at the documentation provided by the author of the CSI driver.</p>
<p>Kubernetes users interested in how to use a CSI driver should look at <a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi">kubernetes.io documentation</a>.</p>
<a class="header" href="#kubernetes-releases" id="kubernetes-releases"><h2>Kubernetes Releases</h2></a>
<table><thead><tr><th> Kubernetes </th><th> CSI Spec Compatibility </th><th> Status </th></tr></thead><tbody>
<tr><td> v1.9       </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0">v0.1.0</a>     </td><td> Alpha  </td></tr>
<tr><td> v1.10      </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0">v0.2.0</a>     </td><td> Beta   </td></tr>
<tr><td> v1.11      </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a>     </td><td> Beta   </td></tr>
<tr><td> v1.13      </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a>, <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> GA     </td></tr>
</tbody></table>
<a class="header" href="#development-and-deployment" id="development-and-deployment"><h1>Development and Deployment</h1></a>
<a class="header" href="#minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes"><h2>Minimum Requirements (for Developing and Deploying a CSI driver for Kubernetes)</h2></a>
<p>Kubernetes is as minimally prescriptive about packaging and deployment of a CSI Volume Driver as possible.</p>
<p>The only requirements are around how Kubernetes (master and node) components find and communicate with a CSI driver.</p>
<p>Specifically, the following is dictated by Kubernetes regarding CSI:</p>
<ul>
<li>Kubelet to CSI Driver Communication
<ul>
<li>Kubelet directly issues CSI calls (like <code>NodeStageVolume</code>, <code>NodePublishVolume</code>, etc.) to CSI drivers via a Unix Domain Socket to mount and unmount volumes.</li>
<li>Kubelet discovers CSI drivers (and the Unix Domain Socket to use to interact with a CSI driver) via the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a>.</li>
<li>Therefore, all CSI drivers deployed on Kubernetes MUST register themselves using the kubelet plugin registration mechanism on each supported node.</li>
</ul>
</li>
<li>Master to CSI Driver Communication
<ul>
<li>Kubernetes master components do not communicate directly (via a Unix Domain Socket or otherwise) with CSI drivers.</li>
<li>Kubernetes master components interact only with the Kubernetes API.</li>
<li>Therefore, CSI drivers that require operations that depend on the Kubernetes API (like volume create, volume attach, volume snapshot, etc.) MUST watch the Kubernetes API and trigger the appropriate CSI operations against it.</li>
</ul>
</li>
</ul>
<p>Because these requirements are minimally prescriptive, CSI driver developers are free to implement and deploy their drivers as they see fit.</p>
<p><em>That said, to ease development and deployment, the mechanism described below is recommended.</em></p>
<a class="header" href="#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes"><h2>Recommended Mechanism (for Developing and Deploying a CSI driver for Kubernetes)</h2></a>
<p>The Kubernetes development team has established a &quot;Recommended Mechanism&quot; for developing, deploying, and testing CSI Drivers on Kubernetes.
It aims to reduce boilerplate code and  simplify the overall process for CSI Driver developers.</p>
<p>This &quot;Recommended Mechanism&quot; makes use of the following components:</p>
<ul>
<li>Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a></li>
<li>Kubernetes CSI <a href="csi-crds.html">CRDs</a></li>
<li>CSI <a href="testing-drivers.html">Driver Testing</a> tools</li>
</ul>
<p>To implement a CSI driver using this mechanism, a CSI driver developer should:</p>
<ol>
<li>Create a containerized application implementing the <em>Identity</em>, <em>Node</em>, and optionally the <em>Controller</em> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a>  (the CSI driver container).
<ul>
<li>See <a href="developing.html">Developing CSI Driver</a> for more information.</li>
</ul>
</li>
<li>Unit test it using csi-sanity.
<ul>
<li>See <a href="unit-testing.html">Driver - Unit Testing</a> for more information.</li>
</ul>
</li>
<li>Define Kubernetes API YAML files that deploy the CSI driver container along with appropriate sidecar containers.
<ul>
<li>See <a href="deploying.html">Deploying in Kubernetes</a> for more information.</li>
</ul>
</li>
<li>Deploy the driver on a Kubernetes cluster and run end-to-end functional tests on it.
<ul>
<li>See <a href="functional-testing.html">Driver - Functional Testing</a></li>
</ul>
</li>
</ol>
<a class="header" href="#reference-links" id="reference-links"><h2>Reference Links</h2></a>
<ul>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">Design Doc</a></li>
</ul>
<a class="header" href="#developing-csi-driver-for-kubernetes" id="developing-csi-driver-for-kubernetes"><h1>Developing CSI Driver for Kubernetes</h1></a>
<p>The first step to creating a CSI driver is writing an application implementing the <a href="https://grpc.io/docs/">gRPC</a> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a></p>
<p>At a minimum, CSI drivers must implement the following CSI services:</p>
<ul>
<li>CSI <code>Identity</code> service
<ul>
<li>Enables callers (Kubernetes components and CSI sidecar containers) to identify the driver and what optional functionality it supports.</li>
</ul>
</li>
<li>CSI <code>Node</code> service
<ul>
<li>Only <code>NodePublishVolume</code>, <code>NodeUnpublishVolume</code>, and <code>NodeGetCapabilities</code> are required.</li>
<li>Required methods enable callers to make a volume available at a specified path and discover what optional  functionality the driver supports.</li>
</ul>
</li>
</ul>
<p>All CSI services may be implemented in the same CSI driver application. The CSI driver application should be containerized to make it easy to deploy on Kubernetes. Once containerized, the CSI driver can be paired with CSI <a href="sidecar-containers.html">Sidecar Containers</a> and deployed in node and/or controller mode as appropriate.</p>
<a class="header" href="#capabilities" id="capabilities"><h2>Capabilities</h2></a>
<p>If your driver supports additional features, CSI &quot;capabilities&quot; can be used to advertise the optional methods/services it supports, for example:</p>
<ul>
<li><code>CONTROLLER_SERVICE</code> (<code>PluginCapability</code>)
<ul>
<li>The entire CSI <code>Controller</code> service is optional. This capability indicates the driver implement one or more of the methods in the CSI <code>Controller</code> service.</li>
</ul>
</li>
<li><code>VOLUME_ACCESSIBILITY_CONSTRAINTS</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the volumes for this driver may not be equally accessible from all nodes in the cluster, and that the driver will return additional topology related information that Kubernetes can use to schedule workloads more intelligently or influence where a volume will be provisioned.</li>
</ul>
</li>
<li><code>VolumeExpansion</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the driver supports resizing (expanding) volumes after creation.</li>
</ul>
</li>
<li><code>CREATE_DELETE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports dynamic volume provisioning and deleting.</li>
</ul>
</li>
<li><code>PUBLISH_UNPUBLISH_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>ControllerPublishVolume</code> and <code>ControllerUnpublishVolume</code> -- operations that correspond to the Kubernetes volume attach/detach operations. This may, for example, result in a &quot;volume attach&quot; operation against the Google Cloud control plane to attach the specified volume to the specified node for the Google Cloud PD CSI Driver.</li>
</ul>
</li>
<li><code>CREATE_DELETE_SNAPSHOT</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports provisioning volume snapshots and the ability to provision new volumes using those snapshots.</li>
</ul>
</li>
<li><code>CLONE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports cloning of volumes.</li>
</ul>
</li>
<li><code>STAGE_UNSTAGE_VOLUME</code> (<code>NodeServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>NodeStageVolume</code> and <code>NodeUnstageVolume</code> -- operations that correspond to the Kubernetes volume device mount/unmount operations. This may, for example, be used to create a global (per node) volume mount of a block storage device.</li>
</ul>
</li>
</ul>
<p>This is an partial list, please see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> for a complete list of capabilities.
Also see the <a href="features.html">Features</a> section to understand how a feature integrates with Kubernetes.</p>
<a class="header" href="#kubernetes-csi-sidecar-containers" id="kubernetes-csi-sidecar-containers"><h1>Kubernetes CSI Sidecar Containers</h1></a>
<p>Kubernetes CSI Sidecar Containers are a set of standard containers that aim to simplify the development and deployment of CSI Drivers on Kubernetes.</p>
<p>These containers contain common logic to watch the Kubernetes API, trigger appropriate operations against the “CSI volume driver” container, and update the Kubernetes API as appropriate.</p>
<p>The containers are intended to be bundled with third-party CSI driver containers and deployed together as pods.</p>
<p>The containers are developed and maintained by the Kubernetes Storage community.</p>
<p>Use of the containers is strictly optional, but highly recommended.</p>
<p>Benefits of these sidecar containers include:</p>
<ul>
<li>Reduction of &quot;boilerplate&quot; code.
<ul>
<li>CSI Driver developers do not have to worry about complicated, &quot;Kubernetes specific&quot; code.</li>
</ul>
</li>
<li>Separation of concerns.
<ul>
<li>Code that interacts with the Kubernetes API is isolated from (and in a different container then) the code that implements the CSI interface.</li>
</ul>
</li>
</ul>
<p>The Kubernetes development team maintains the following Kubernetes CSI Sidecar Containers:</p>
<ul>
<li><a href="external-provisioner.html">external-provisioner</a></li>
<li><a href="external-attacher.html">external-attacher</a></li>
<li><a href="external-snapshotter.html">external-snapshotter</a></li>
<li><a href="node-driver-registrar.html">node-driver-registrar</a></li>
<li><a href="cluster-driver-registrar.html">cluster-driver-registrar</a></li>
<li><a href="livenessprobe.html">livenessprobe</a></li>
</ul>
<a class="header" href="#csi-external-provisioner" id="csi-external-provisioner"><h1>CSI external-provisioner</h1></a>
<a class="header" href="#status-and-releases" id="status-and-releases"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/external-provisioner</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.0.1">external-provisioner v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-provisioner:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v0.4.2">external-provisioner v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/csi-provisioner:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description" id="description"><h2>Description</h2></a>
<p>The CSI <code>external-provisioner</code> is a sidecar container that watches the Kubernetes API server for <code>PersistentVolumeClaim</code> objects.</p>
<p>It calls <code>CreateVolume</code> against the specified CSI endpoint to provision a new volume.</p>
<p>Volume provisioning is triggered by the creation of a new Kubernetes <code>PersistentVolumeClaim</code> object, if the PVC references a Kubernetes <code>StorageClass</code>, and the name in the <code>provisioner</code> field of the storage class matches the name returned by the specified CSI endpoint in the <code>GetPluginInfo</code> call.</p>
<p>Once a new volume is successfully provisioned, the sidecar container creates a Kubernetes <code>PersistentVolume</code> object to represent the volume.</p>
<p>The deletion of a <code>PersistentVolumeClaim</code> object bound to a <code>PersistentVolume</code> corresponding to this driver with a <code>delete</code> reclaim policy causes the sidecar container to trigger a <code>DeleteVolume</code> operation against the specified CSI endpoint to delete the volume. Once the volume is successfully deleted, the sidecar container also deletes the <code>PersistentVolume</code> object representing the volume.</p>
<p>The CSI <code>external-provisioner</code> also supports the <code>Snapshot</code> DataSource. If a <code>Snapshot</code> CRD is specified as a data source on a PVC object, the sidecar container fetches the information about the snapshot by fetching the <code>SnapshotContent</code> object and populates the data source field in the resulting <code>CreateVolume</code> call to indicate to the storage system that the new volume should be populated using the specified snapshot.</p>
<a class="header" href="#storageclass-parameters" id="storageclass-parameters"><h3>StorageClass Parameters</h3></a>
<p>When provisioning a new volume, the CSI <code>external-provisioner</code> sets the <code>map&lt;string, string&gt; parameters</code> field in the CSI <code>CreateVolumeRequest</code> call to the key/values specified in the <code>StorageClass</code> it is handling.</p>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) also reserves the parameter keys prefixed with <code>csi.storage.k8s.io/</code>. Any keys prefixed with <code>csi.storage.k8s.io/</code> are not passed to the CSI driver as an opaque <code>parameter</code>.</p>
<p>The following reserved <code>StorageClass</code> parameter keys trigger behavior in the CSI <code>external-provisioner</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/fstype</code></li>
</ul>
<p>If the PVC <code>VolumeMode</code> is set to <code>Filesystem</code>, and the value of <code>csi.storage.k8s.io/fstype</code> is specified, it is used to populate the <code>FsType</code> in <code>CreateVolumeRequest.VolumeCapabilities[x].AccessType</code> and the <code>AccessType</code> is set to <code>Mount</code>.</p>
<p>For more information on how secrets are handled see <a href="secrets-and-credentials.html">Secrets &amp; Credentials</a>.</p>
<p>Example <code>StorageClass</code>:</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gold-example-storage
provisioner: exampledriver.example.com
parameters:
  disk-type: ssd
  csi.storage.k8s.io/fstype: ext4
  csi.storage.k8s.io/provisioner-secret-name: mysecret
  csi.storage.k8s.io/provisioner-secret-namespace: mynamespace
</code></pre>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>CSI drivers that support dynamic volume provisioning should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md.</p>
<a class="header" href="#deployment" id="deployment"><h2>Deployment</h2></a>
<p>The CSI <code>external-provisioner</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-external-attacher" id="csi-external-attacher"><h1>CSI external-attacher</h1></a>
<a class="header" href="#status-and-releases-1" id="status-and-releases-1"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/external-attacher</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v1.0.1">external-attacher v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-attacher/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-attacher:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v0.4.2">external-attacher v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/external-attacher/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/csi-attacher:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-1" id="description-1"><h2>Description</h2></a>
<p>The CSI <code>external-attacher</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeAttachment</code> objects and triggers <code>Controller[Publish|Unpublish]Volume</code> operations against a CSI endpoint.</p>
<a class="header" href="#usage-1" id="usage-1"><h2>Usage</h2></a>
<p>CSI drivers that require integrating with the Kubernetes volume attach/detach hooks should use this sidecar container, and advertise the CSI <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/external-attacher/blob/master/README.md.</p>
<a class="header" href="#deployment-1" id="deployment-1"><h2>Deployment</h2></a>
<p>The CSI <code>external-attacher</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-external-snapshotter" id="csi-external-snapshotter"><h1>CSI external-snapshotter</h1></a>
<a class="header" href="#status-and-releases-2" id="status-and-releases-2"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/external-snapshotter</p>
<p><strong>Status:</strong> Alpha</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v1.0.1">external-snapshotter v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-snapshotter:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v0.4.1">external-snapshotter v0.4.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/csi-snapshotter:v0.4.1 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-2" id="description-2"><h2>Description</h2></a>
<p>The CSI <code>external-snapshotter</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects.</p>
<p>The creation of a new <code>VolumeSnapshot</code> object referencing a <code>SnapshotClass</code> CRD object corresponding to this driver causes the sidecar container to trigger a <code>CreateSnapshot</code> operation against the specified CSI endpoint to provision a new snapshot. When a new snapshot is successfully provisioned, the sidecar container creates a Kubernetes <code>VolumeSnapshotContent</code> object to represent the new snapshot.</p>
<p>The deletion of a <code>VolumeSnapshot</code> object bound to a <code>VolumeSnapshotContent</code> corresponding to this driver with a <code>delete</code> reclaim policy causes the sidecar container to trigger a <code>DeleteSnapshot</code> operation against the specified CSI endpoint to delete the snapshot. Once the snapshot is successfully deleted, the sidecar container also deletes the <code>VolumeSnapshotContent</code> object representing the snapshot.</p>
<p>For detailed information about volume snapshot and restore functionality, see <a href="snapshot-restore-feature.html">Volume Snapshot &amp; Restore</a>.</p>
<a class="header" href="#usage-2" id="usage-2"><h2>Usage</h2></a>
<p>CSI drivers that support provisioning volume snapshots and the ability to provision new volumes using those snapshots should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_SNAPSHOT</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/external-snapshotter/blob/master/README.md.</p>
<a class="header" href="#deployment-2" id="deployment-2"><h2>Deployment</h2></a>
<p>The CSI <code>external-snapshotter</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<p>For an example deployment, see <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/deploy/kubernetes/setup-csi-snapshotter.yaml">this example</a> which deploys <code>external-snapshotter</code> and <code>external-provisioner</code> with the Hostpath CSI driver.</p>
<a class="header" href="#csi-node-driver-registrar" id="csi-node-driver-registrar"><h1>CSI node-driver-registrar</h1></a>
<a class="header" href="#status-and-releases-3" id="status-and-releases-3"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/node-driver-registrar</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v1.0.2">node-driver-registrar v1.0.2</a> </td><td> <a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-node-driver-registrar:v1.0.2 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/driver-registrar:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-3" id="description-3"><h2>Description</h2></a>
<p>The CSI <code>node-driver-registrar</code> is a sidecar container that fetches driver information (using <code>NodeGetInfo</code>) from a CSI endpoint and registers it with the kubelet on that node using the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a>.</p>
<a class="header" href="#usage-3" id="usage-3"><h2>Usage</h2></a>
<p>Kubelet directly issues CSI <code>NodeGetInfo</code>, <code>NodeStageVolume</code>, and <code>NodePublishVolume</code> calls against CSI drivers. It uses the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a> to discover the unix domain socket to talk to the CSI driver. Therefore, all CSI drivers should use this sidecar container to register themselves with kubelet.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<a class="header" href="#deployment-3" id="deployment-3"><h2>Deployment</h2></a>
<p>The CSI <code>node-driver-registrar</code> is deployed per node. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-cluster-driver-registrar" id="csi-cluster-driver-registrar"><h1>CSI cluster-driver-registrar</h1></a>
<a class="header" href="#status-and-releases-4" id="status-and-releases-4"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/cluster-driver-registrar</p>
<p><strong>Status:</strong> Alpha</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/cluster-driver-registrar/releases/tag/v1.0.1">cluster-driver-registrar v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/cluster-driver-registrar/tree/release-1.0">release-1.0</a> </td><td>  <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-cluster-driver-registrar:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/driver-registrar:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-4" id="description-4"><h2>Description</h2></a>
<p>The CSI <code>cluster-driver-registrar</code> is a sidecar container that registers a CSI Driver with a Kubernetes cluster by creating a <a href="csi-driver-object.html">CSIDriver Object</a> which enables the driver to customize how Kubernetes interacts with it.</p>
<a class="header" href="#usage-4" id="usage-4"><h2>Usage</h2></a>
<p>CSI drivers that use one of the following Kubernetes features should use this sidecar container:</p>
<ul>
<li><a href="skip-attach.html">Skip Attach</a>
<ul>
<li>For drivers that don't support <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume"><code>ControllerPublishVolume</code></a>, this indicates to Kubernetes to skip the attach operation and eliminates the need to deploy the <code>external-attacher</code> sidecar.</li>
</ul>
</li>
<li><a href="pod-info.html">Pod Info on Mount</a>
<ul>
<li>This causes Kubernetes to pass metadata such as Pod name and namespace to the <code>NodePublishVolume</code> call.</li>
</ul>
</li>
</ul>
<p>If you are not using one of these features, this sidecar container (and the creation of the <a href="csi-driver-object.html">CSIDriver Object</a>) is not required. However, it is still recommended, because the <a href="csi-driver-object.html">CSIDriver Object</a> makes it easier for users to easily discover the CSI drivers installed on their clusters.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<a class="header" href="#deployment-4" id="deployment-4"><h2>Deployment</h2></a>
<p>The CSI <code>cluster-driver-registrar</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-livenessprobe" id="csi-livenessprobe"><h1>CSI livenessprobe</h1></a>
<a class="header" href="#status-and-releases-5" id="status-and-releases-5"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/livenessprobe</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v1.0.2">livenessprobe v1.0.2</a> </td><td> <a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/livenessprobe:v1.0.2 </td><td> v1.13 </td><td> -</td></tr>
<tr><td>Unsupported. </td><td> No 0.x branch. </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/livenessprobe:v0.4.1 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-5" id="description-5"><h2>Description</h2></a>
<p>The CSI <code>livenessprobe</code> is a sidecar container that monitors the health of the CSI driver and reports it to Kubernetes via the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">Liveness Probe mechanism</a>. This enables Kubernetes to automatically detect issues with the driver and restart the pod to try and fix the issue.</p>
<a class="header" href="#usage-5" id="usage-5"><h2>Usage</h2></a>
<p>All CSI drivers should use the liveness probe to improve the availability of the driver while deployed on Kubernetes.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/livenessprobe/blob/master/README.md.</p>
<a class="header" href="#deployment-5" id="deployment-5"><h2>Deployment</h2></a>
<p>The CSI <code>livenessprobe</code> is deployed as part of controller and node deployments. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-crds" id="csi-crds"><h1>CSI CRDs</h1></a>
<p><strong>Status:</strong> Alpha</p>
<p>The Kubernetes CSI development team created a set of <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definitions</a> (CRDs).</p>
<p>There are currently two CRDs:</p>
<ul>
<li><a href="csi-driver-object.html">CSIDriver Object</a></li>
<li><a href="csi-node-info-object.html">CSINodeInfo Object</a></li>
</ul>
<p>Definitions of the CRDs can be found <a href="https://github.com/kubernetes/csi-api/tree/master/pkg/crd/manifests">here</a>.</p>
<p>The CRDs are automatically deployed on Kubernetes via a Kubernetes Storage CRD addon https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/storage-crds. Ensure your Kubernetes Cluster deployment mechanisms (kops, etc.) enable the addon and/or installs the CRDs.</p>
<p>To verify the CRDs are installed, issue the following commands: <code>kubectl get crd</code>. Verify the result includes the CRDs. If deployment does not automatically install the CRD, CRDs may be manually installed via <code>kubectl create -f {file}.yaml</code> using the files <a href="https://github.com/kubernetes/csi-api/tree/master/pkg/crd/manifests">here</a>.</p>
<p>The schema definition for the custom resources (CRs) can be found here: https://github.com/kubernetes/csi-api/blob/master/pkg/apis/csi/v1alpha1/types.go</p>
<a class="header" href="#csidriver-object" id="csidriver-object"><h1>CSIDriver Object</h1></a>
<a class="header" href="#status" id="status"><h2>Status</h2></a>
<p>Alpha</p>
<a class="header" href="#what-is-the-csidriver-object" id="what-is-the-csidriver-object"><h2>What is the CSIDriver object?</h2></a>
<p>The <code>CSIDriver</code> Kubernetes API object serves two purposes:</p>
<ol>
<li>Simplify driver discovery</li>
</ol>
<ul>
<li>If a CSI driver creates a <code>CSIDriver</code> object, Kubernetes users can easily discover the CSI Drivers installed on their cluster (simply by issuing <code>kubectl get CSIDriver</code>)</li>
</ul>
<ol start="2">
<li>Customizing Kubernetes behavior</li>
</ol>
<ul>
<li>Kubernetes has a default set of behaviors when dealing with CSI Drivers (for example, it calls the <code>Attach</code>/<code>Detach</code> operations by default). This object allows CSI drivers to specify how Kubernetes should interact with it.</li>
</ul>
<a class="header" href="#what-fields-does-the-csidriver-object-have" id="what-fields-does-the-csidriver-object-have"><h2>What fields does the <code>CSIDriver</code> object have?</h2></a>
<p>Here is an example of a v1alpha1 <code>CSIDriver</code> object:</p>
<pre><code class="language-YAML">apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
  name: mycsidriver.example.com
spec:
  attachRequired: true
  podInfoOnMountVersion: v1
</code></pre>
<p>There are three important fields:</p>
<ul>
<li><code>name</code>
<ul>
<li>This should correspond to the full name of the CSI driver.</li>
</ul>
</li>
<li><code>attachRequired</code>
<ul>
<li>Indicates this CSI volume driver requires an attach operation (because it implements the CSI <code>ControllerPublishVolume</code> method), and that Kubernetes should call attach and wait for any attach operation to complete before proceeding to mounting.</li>
<li>If a <code>CSIDriver</code> object does not exist for a given CSI Driver, the default is <code>true</code> -- meaning attach will be called.</li>
<li>If a <code>CSIDriver</code> object exists for a given CSI Driver, but this field is not specified, it also defaults to <code>true</code> -- meaning attach will be called.</li>
<li>For more information see <a href="skip-attach.html">Skip Attach</a>.</li>
</ul>
</li>
<li><code>podInfoOnMountVersion</code>
<ul>
<li>Indicates this CSI volume driver requires additional pod information (like pod name, pod UID, etc.) during mount operations.</li>
<li>If value is not specified, pod information will not be passed on mount.</li>
<li>If value is set to a valid version, Kubelet will pass pod information as <code>volume_context</code> in CSI <code>NodePublishVolume</code> calls.</li>
<li>Supported versions:
<ul>
<li>Version &quot;v1&quot; will pass the following additional fields in <code>volume_context</code>:
<ul>
<li><code>&quot;csi.storage.k8s.io/pod.name&quot;: pod.Name</code></li>
<li><code>csi.storage.k8s.io/pod.namespace&quot;: pod.Namespace</code></li>
<li><code>csi.storage.k8s.io/pod.uid&quot;: string(pod.UID)</code></li>
</ul>
</li>
</ul>
</li>
<li>For more information see <a href="pod-info.html">Pod Info on Mount</a>.</li>
</ul>
</li>
</ul>
<a class="header" href="#what-creates-the-csidriver-object" id="what-creates-the-csidriver-object"><h2>What creates the CSIDriver object?</h2></a>
<p>CSI drivers do not need to create the <code>CSIDriver</code> object directly. Instead they may use the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container (customizing it as needed with startup parameters) -- when deployed with a CSI driver it automatically creates a <code>CSIDriver</code> CR representing the driver.</p>
<a class="header" href="#enabling-csidriver" id="enabling-csidriver"><h3>Enabling CSIDriver</h3></a>
<p>The <code>CSIDriver</code> object is available as alpha starting with Kubernetes v1.12. Because it is an alpha feature, it is disabled by default.
It is planned to be moved to beta in Kubernetes v1.14 and enabled by default.</p>
<p>To enable the use of <code>CSIDriver</code> on Kubernetes, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled via the following Kubernetes feature flag: <code>--feature-gates=CSIDriverRegistry=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSIDriver</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csidriver.yaml
</code></pre>
<a class="header" href="#listing-registered-csi-drivers" id="listing-registered-csi-drivers"><h3>Listing registered CSI drivers</h3></a>
<p>Using the <code>CSIDriver</code> CRD, it is now possible to query Kubernetes to get a list of registered drivers running in the cluster as shown below:</p>
<pre><code>$&gt; kubectl get csidrivers.csi.storage.k8s.io
NAME           AGE
csi-hostpath   2m
</code></pre>
<p>Or get a more detailed view of your registered driver with:</p>
<pre><code>$&gt; kubectl describe csidrivers.csi.storage.k8s.io
Name:         csi-hostpath
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  csi.storage.k8s.io/v1alpha1
Kind:         CSIDriver
Metadata:
  Creation Timestamp:  2018-10-04T21:15:30Z
  Generation:          1
  Resource Version:    390
  Self Link:           /apis/csi.storage.k8s.io/v1alpha1/csidrivers/csi-hostpath
  UID:                 9f854aa6-c81a-11e8-bdce-000c29e88ff1
Spec:
  Attach Required:            true
  Pod Info On Mount Version:
Events:                       &lt;none&gt;
</code></pre>
<a class="header" href="#csinodeinfo-object" id="csinodeinfo-object"><h1>CSINodeInfo Object</h1></a>
<a class="header" href="#status-1" id="status-1"><h2>Status</h2></a>
<p>Alpha</p>
<a class="header" href="#what-is-the-csinodeinfo-object" id="what-is-the-csinodeinfo-object"><h2>What is the CSINodeInfo object?</h2></a>
<p>CSI drivers generate node specific information. Instead of storing this in the Kubernetes <code>Node</code> API Object, a new CSI specific Kubernetes CRD was created, the <code>CSINodeInfo</code> CRD.</p>
<p>It serves the following purposes:</p>
<ol>
<li>Mapping Kubernetes node name to CSI Node name,</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns the name by which the storage system refers to a node. Kubernetes must use this name in future <code>ControllerPublishVolume</code> calls. Therefore, when a new CSI driver is registered, Kubernetes stores the storage system node ID in the <code>CSINodeInfo</code> object for future reference.</li>
</ul>
<ol start="2">
<li>Driver availability</li>
</ol>
<ul>
<li>A way for kubelet to communicate to the kube-controller-manager and kubernetes scheduler whether the driver is available (registered) on the node or not.</li>
</ul>
<ol start="3">
<li>Volume topology</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns a set of keys/values labels identifying the topology of that node. Kubernetes uses this information to to do topology-aware provisioning (see <a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode">PVC Volume Binding Modes</a> for more details). It stores the key/values as labels on the Kubernetes node object. In order to recall which <code>Node</code> label keys belong to a specific CSI driver, the kubelet stores the keys in the <code>CSINodeInfo</code> object for future reference.</li>
</ul>
<a class="header" href="#what-fields-does-the-csinodeinfo-object-have" id="what-fields-does-the-csinodeinfo-object-have"><h2>What fields does the CSINodeInfo object have?</h2></a>
<p>Here is an example of a v1alpha1 <code>CSINodeInfo</code> object:</p>
<pre><code class="language-YAML">apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSINodeInfo
metadata:
  name: node1
spec:
  drivers:
  - name: mycsidriver.example.com
    available: true
    volumePluginMechanism: csi-plugin
status:
  drivers:
  - name: mycsidriver.example.com
    nodeID: storageNodeID1
    topologyKeys: ['mycsidriver.example.com/regions', &quot;mycsidriver.example.com/zones&quot;]
</code></pre>
<p>Where the fields mean:</p>
<ul>
<li><code>csiDrivers</code> - list of CSI drivers running on the node and their properties.</li>
<li><code>driver</code> - the CSI driver that this object refers to.</li>
<li><code>nodeID</code> - the assigned identifier for the node as determined by the driver.</li>
<li><code>topologyKeys</code> - A list of topology keys assigned to the node as supported by the driver.</li>
</ul>
<a class="header" href="#what-creates-the-csinodeinfo-object" id="what-creates-the-csinodeinfo-object"><h2>What creates the CSINodeInfo object?</h2></a>
<p>CSI drivers do not need to create the <code>CSINodeInfo</code> object directly. As long as they use the <a href="node-driver-registrar.html">node-driver-registrar</a> sidecar container, the kubelet will automatically populate the <code>CSINodeInfo</code> object for the CSI driver as part of kubelet plugin registration.</p>
<a class="header" href="#enabling-csinodeinfo" id="enabling-csinodeinfo"><h3>Enabling CSINodeInfo</h3></a>
<p>The <code>CSINodeInfo</code> object is available as alpha starting with Kubernetes v1.12. Because it is an alpha feature, it is disabled by default.</p>
<p>To enable use of <code>CSINodeInfo</code> on Kubernetes, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled with <code>--feature-gates=CSINodeInfo=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSINodeInfo</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csinodeinfo.yaml
</code></pre>
<a class="header" href="#features" id="features"><h1>Features</h1></a>
<p>The Kubernetes implementation of CSI has multiple sub-features. This section describes these sub-features, their status (although support for CSI in Kubernetes is GA/stable, support of sub-features moves independently so sub-features maybe alpha or beta), and how to integrate them in to your CSI Driver.</p>
<a class="header" href="#secrets-and-credentials" id="secrets-and-credentials"><h1>Secrets and Credentials</h1></a>
<a class="header" href="#csi-driver-secrets" id="csi-driver-secrets"><h2>CSI Driver Secrets</h2></a>
<p>Some drivers may require a secret in order to issue operations against a backend (a service account, for example).
If this secret is required at the &quot;per driver&quot; granularity (and not different &quot;per CSI operation&quot; or &quot;per volume&quot;), the secret may be injected in to CSI driver pods via <a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">standard Kubernetes secret distribution mechanisms</a>.</p>
<a class="header" href="#csi-operation-secrets" id="csi-operation-secrets"><h2>CSI Operation Secrets</h2></a>
<p>The CSI spec also accepts secrets in each of the following protos:</p>
<ul>
<li><code>CreateVolumeRequest</code></li>
<li><code>DeleteVolumeRequest</code></li>
<li><code>ControllerPublishVolumeRequest</code></li>
<li><code>ControllerUnpublishVolumeRequest</code></li>
<li><code>CreateSnapshotRequest</code></li>
<li><code>DeleteSnapshotRequest</code></li>
<li><code>ControllerExpandVolumeRequest</code></li>
<li><code>NodeStageVolumeRequest</code></li>
<li><code>NodePublishVolumeRequest</code></li>
</ul>
<p>These enable CSI drivers to accept/require &quot;per CSI operation&quot; or &quot;per volume&quot; secrets (a volume encryption key, for example).</p>
<p>The CSI <a href="external-provisioner.html">external-provisioner</a> enables Kubernetes cluster admins to populate the secret fields for these protos with data from Kubernetes <code>Secret</code> objects. For example:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/provisioner-secret-name: fast-storage-provision-key
  csi.storage.k8s.io/provisioner-secret-namespace: pd-ssd-credentials
</code></pre>
<a class="header" href="#createdelete-volume-secret" id="createdelete-volume-secret"><h3>Create/Delete Volume Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variable that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<pre><code>* `${pv.name}`
  * Automatically replaced with the name of the `PersistentVolume` object being provisioned at provision.
</code></pre>
<p>If specified, the CSI <code>external-provisioner</code> will attempt to fetch the secret before provisioning and deletion.</p>
<p>If no such secret exists in the Kubernetes API, or the provisioner is unable to fetch it, the provision or delete operation fails.</p>
<p>If the secret is retrieved successfully, the provisioner passes it to the CSI driver in the <code>CreateVolumeRequest.secrets</code> or <code>DeleteVolumeRequest.secrets</code> field.</p>
<a class="header" href="#controller-publishunpublish-secret" id="controller-publishunpublish-secret"><h3>Controller Publish/Unpublish Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variables that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Automatically replaced with the namespace of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>The value of <code>csi.storage.k8s.io/controller-publish-secret-namespace</code> also supports the following template variables which are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pvc.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Automatically replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>If specified, once provisioning is successful, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret.</p>
<p>If specified, the CSI <code>external-attacher</code> attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code> before an attach or detach operation.</p>
<p>If no such secret exists in the Kubernetes API, or the <code>external-attacher</code> is unable to fetch it, the attach or detach operation fails.</p>
<p>If the secret is retrieved successfully, the <code>external-attacher</code> passes it to the CSI driver in the <code>ControllerPublishVolumeRequest.secrets</code> or <code>ControllerUnpublishVolumeRequest.secrets</code> field.</p>
<a class="header" href="#node-stage-secret" id="node-stage-secret"><h3>Node Stage Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variables that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Automatically replaced with the namespace of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>The value of <code>csi.storage.k8s.io/node-stage-secret-namespace</code> also supports the following template variables which are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pvc.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Automatically replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>If specified, once provisioning is successful, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret.</p>
<p>If specified, the Kubernetes kubelet, attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field before a mount device operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount device operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodeStageVolumeRequest.secrets</code> field.</p>
<a class="header" href="#node-publish-secret" id="node-publish-secret"><h3>Node Publish Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variables that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Automatically replaced with the namespace of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>The value of <code>csi.storage.k8s.io/node-publish-secret-namespace</code> also supports the following template variables which are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pvc.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Automatically replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>If specified, once provisioning is successful, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret.</p>
<p>If specified, the Kubernetes kubelet, attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field before a mount operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodePublishVolumeRequest.secrets</code> field.</p>
<p>For example, consider this <code>StorageClass</code>:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csiNodePublishSecretName: ${pvc.annotations['team.example.com/key']}
  csiNodePublishSecretNamespace: ${pvc.namespace}
</code></pre>
<p>This StorageClass instructs the CSI provisioner to do the following:</p>
<ul>
<li>Create a <code>PersistentVolume</code> with:
<ul>
<li>a &quot;node publish secret&quot; in the same namespace as the <code>PersistentVolumeClaim</code> that triggered the provisioning, with a name specified as an annotation on the <code>PersistentVolumeClaim</code>. This could be used to give the creator of the <code>PersistentVolumeClaim</code> the ability to specify a secret containing a decryption key they have control over.</li>
</ul>
</li>
</ul>
<a class="header" href="#handling-sensitive-information" id="handling-sensitive-information"><h2>Handling Sensitive Information</h2></a>
<p>CSI Drivers that accept secrets SHOULD handle this data carefully. It may contain sensitive information and MUST be treated as such (e.g. not logged).</p>
<p>To make it easier to handle secret fields (e.g. strip them from CSI protos when logging), the CSI spec defines a decorator (<code>csi_secret</code>) on all fields containing sensitive information. Any fields decorated with <code>csi_secret</code> MUST be treated as if they contain sensitive information (e.g. not logged, etc.).</p>
<p>The Kubernetes CSI development team also provides a GO lang package called <code>protosanitizer</code> that CSI driver developers may be used to remove values for all fields in a gRPC messages decorated with <code>csi_secret</code>. The library can be found in <a href="https://github.com/kubernetes-csi/csi-lib-utils/tree/master/protosanitizer">kubernetes-csi/csi-lib-utils/protosanitizer</a>. The Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a> and sample drivers use this library to ensure no sensitive information is logged.</p>
<a class="header" href="#snapshot--restore-feature" id="snapshot--restore-feature"><h1>Snapshot &amp; Restore Feature</h1></a>
<p><strong>Status:</strong> Alpha</p>
<p>Many storage systems provide the ability to create a &quot;snapshot&quot; of a persistent volume. A snapshot represents a point-in-time copy of a volume. A snapshot can be used either to provision a new volume (pre-populated with the snapshot data) or to restore the existing volume to a previous state (represented by the snapshot).</p>
<p>Kubernetes CSI currently enables CSI Drivers to expose the following functionality via the Kubernetes API:</p>
<ol>
<li>Creation and deletion of volume snapshots via <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes native API</a>.</li>
<li>Creation of new volumes pre-populated with the data from a snapshot via Kubernetes <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">dynamic volume provisioning</a>.</li>
</ol>
<a class="header" href="#implementing-snapshot--restore-functionality" id="implementing-snapshot--restore-functionality"><h2>Implementing Snapshot &amp; Restore Functionality</h2></a>
<p>To implement the snapshot feature, a CSI driver MUST:</p>
<ul>
<li>Implement the <code>CREATE_DELETE_SNAPSHOT</code> and, optionally, the <code>LIST_SNAPSHOTS</code> controller capabilities</li>
<li>Implement <code>CreateSnapshot</code>, <code>DeleteSnapshot</code>, and, optionally, the <code>ListSnapshots</code>, controller RPCs.</li>
</ul>
<p>For details,  see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a>.</p>
<a class="header" href="#deploying-snapshot--restore-functionality" id="deploying-snapshot--restore-functionality"><h2>Deploying Snapshot &amp; Restore Functionality</h2></a>
<p>The Kubernetes CSI development team maintains the <a href="external-snapshotter.html">external-snapshotter</a> Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a>. This sidecar container implements the logic for watching the Kubernetes API for snapshot objects and issuing the appropriate CSI snapshot calls against a CSI endpoint. For more details, see <a href="external-snapshotter.html">external-snapshotter documentation</a>.</p>
<a class="header" href="#snapshot-apis" id="snapshot-apis"><h2>Snapshot APIs</h2></a>
<p>Similar to the API for managing <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Kubernetes Persistent Volumes</a>, the Kubernetes Volume Snapshots introduce three new API objects for managing snapshots: <code>VolumeSnapshot</code>, <code>VolumeSnapshotContent</code>, and <code>VolumeSnapshotClass</code>. See <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes Snapshot documentation</a> for more details.</p>
<p>Unlike the core Kubernetes Persistent Volume objects, these Snapshot objects are defined as <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definitions</a> (CRDs). This is because the Kubernetes project is moving away from having resource types pre-defined in the API server. This allows the API server to be reused for projects other than Kubernetes, and consumers (like Kubernetes) simply install the resource types they require as CRDs. Because the Snapshot API types are not built in to Kubernetes, they must be installed prior to use.</p>
<p>The CRDs are <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/master/cmd/csi-snapshotter/create_crd.go#L29">automatically deployed</a> by the CSI <a href="external-snapshotter.html">external-snapshotter</a> sidecar.</p>
<p>The schema definition for the custom resources (CRs) can be found here: https://github.com/kubernetes-csi/external-snapshotter/blob/master/pkg/apis/volumesnapshot/v1alpha1/types.go</p>
<p>In addition to these new CRD objects, a new, alpha <code>DataSource</code> field has been added to the <code>PersistentVolumeClaim</code> object. This new field enables dynamic provisioning of new volumes that are automatically pre-populated with data from an existing snapshot.</p>
<p>Since volume snapshot is an alpha feature in Kubernetes v1.12, you need to enable a new alpha feature gate called <code>VolumeSnapshotDataSource</code> in the Kubernetes API server binary.</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true
</code></pre>
<a class="header" href="#test-snapshot-feature" id="test-snapshot-feature"><h2>Test Snapshot Feature</h2></a>
<p>Use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/examples/kubernetes">example yaml files</a> to test the snapshot feature.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kuberctl create -f restore.yaml
</code></pre>
<a class="header" href="#persistentvolumeclaim-not-bound" id="persistentvolumeclaim-not-bound"><h3>PersistentVolumeClaim not Bound</h3></a>
<p>If a <code>PersistentVolumeClaim</code> is not bound, the attempt to create a volume snapshot from that <code>PersistentVolumeClaim</code> will fail. No retries will be attempted. An event will be logged to indicate that the <code>PersistentVolumeClaim</code> is not bound.</p>
<p>Note that this could happen if the <code>PersistentVolumeClaim</code> spec and the <code>VolumeSnapshot</code> spec are in the same YAML file. In this case, when the <code>VolumeSnapshot</code> object is created, the <code>PersistentVolumeClaim</code> object is created but volume creation is not complete and therefore the <code>PersistentVolumeClaim</code> is not yet bound. You must wait until the <code>PersistentVolumeClaim</code> is bound and then create the snapshot.</p>
<a class="header" href="#examples" id="examples"><h2>Examples</h2></a>
<p>The following CSI drivers implement the snapshot feature and maybe referred to for example implementations:</p>
<ul>
<li><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE PD CSI driver</a></li>
<li><a href="https://github.com/opensds/nbp/tree/master/csi/server">OpenSDS CSI driver</a></li>
<li><a href="https://github.com/ceph/ceph-csi/tree/master/pkg/rbd">Ceph RBD CSI driver</a></li>
<li><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS CSI driver</a></li>
</ul>
<a class="header" href="#csi-topology-feature" id="csi-topology-feature"><h1>CSI Topology Feature</h1></a>
<blockquote>
<a class="header" href="#this-page-is-still-under-active-development" id="this-page-is-still-under-active-development"><h2><em>This page is still under active development.</em></h2></a>
</blockquote>
<p><strong>Status:</strong> Alpha</p>
<p>Some storage systems expose volumes that are not equally accessible by all nodes in a Kubernetes cluster. Instead volumes may be constrained to some subset of node(s) in the cluster. The cluster may be segmented into, for example, “racks” or “regions” and “zones” or some other grouping, and a given volume may be accessible only from one of those groups.</p>
<p>To enable orchestration systems, like Kubernetes, to work well with storage systems which expose volumes that are not equally accessible by all nodes, the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> enables:</p>
<ol>
<li>Ability for a CSI Driver to opaquely specify where a particular node exists (e.g. &quot;node A&quot; is in &quot;zone 1&quot;).</li>
<li>Ability for Kubernetes (users or components) to influence where a volume is provisioned (e.g. provision new volume in either &quot;zone 1&quot; or &quot;zone 2&quot;).</li>
<li>Ability for a CSI Driver to opaquely specify where a particular volume exists (e.g. &quot;volume X&quot; is accessible by all nodes in &quot;zone 1&quot; and &quot;zone 2&quot;).</li>
</ol>
<p>Kubernetes and the Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a> use these abilities to make intelligent scheduling and provisioning decisions (that Kubernetes can both influence and act on topology information for each volume),</p>
<a class="header" href="#implementing-topology" id="implementing-topology"><h2>Implementing Topology</h2></a>
<p>TODO: Explain the CSI calls and capabilities that must be implemented.
TODO: Explain what CSI CRDs the feature depends on.</p>
<a class="header" href="#usage-6" id="usage-6"><h2>Usage</h2></a>
<p>In order to support topology-aware dynamic provisioning mechanisms available in Kubernetes, the <em>external-provisioner</em> must have the Topology feature enabled:</p>
<pre><code>--feature-gates=Topology=true
</code></pre>
<p>In addition, in the <em>Kubernetes cluster</em> the <code>CSINodeInfo</code> alpha feature must be enabled (refer to the <a href="csi-node-info-object.html">CSINodeInfo Object</a> section for more info):</p>
<pre><code>--feature-gates=CSINodeInfo=true
</code></pre>
<p>The <code>KubeletPluginsWatcher</code> feature must also be enabled (GA and enabled by default in Kubernetes 1.13).</p>
<a class="header" href="#storage-internal-topology" id="storage-internal-topology"><h2>Storage Internal Topology</h2></a>
<p>Note that a storage system may also have an &quot;internal topology&quot; different from (independent of) the topology of the cluster where workloads are scheduled. Meaning volumes exposed by the storage system are equally accessible by all nodes in the Kubernetes cluster, but the storage system has some internal topology that may influence, for example, the performance of a volume from a given node.</p>
<p>CSI does not currently expose a first class mechanism to influence such storage system internal topology on provisioning. Therefore, Kubernetes can not programmatically influence such topology. However, a CSI Driver may expose the ability to specify internal storage topology during volume provisioning using an opaque parameter in the <code>CreateVolume</code> CSI call (CSI enables CSI Drivers to expose an arbitrary set of configuration options during dynamic provisioning by allowing opaque parameters to be passed from cluster admins to the storage plugins) -- this would enable cluster admins to be able to control the storage system internal topology during provisioning.</p>
<a class="header" href="#raw-block-volume-feature" id="raw-block-volume-feature"><h1>Raw Block Volume Feature</h1></a>
<blockquote>
<a class="header" href="#this-page-is-still-under-active-development-1" id="this-page-is-still-under-active-development-1"><h2><em>This page is still under active development.</em></h2></a>
</blockquote>
<p><strong>Status:</strong> Alpha</p>
<p>This page documents how to implement raw block volume support to a CSI Driver.</p>
<p>A <em>block volume</em> is a volume that will appear as a block device inside the container.
A <em>mounted (file) volume</em> is volume that will be mounted using a specified file system and appear as a directory inside the container.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> supports both block and mounted (file) volumes.</p>
<p>While Kubernetes support of mounted (file) volumes is GA/stable, support for <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#raw-block-volume-support">block volume in Kubernetes</a> was introduced in v1.9, and promoted to beta in Kubernetes 1.13.</p>
<p>The Kubernetes CSI tooling support for block volumes is still alpha.</p>
<a class="header" href="#usage-7" id="usage-7"><h2>Usage</h2></a>
<p>Because this feature is still alpha it is disabled by default in Kubernetes. You must enable the feature on Kubernetes:</p>
<pre><code>--feature-gates=BlockVolume=true,CSIBlockVolume=true...
</code></pre>
<a class="header" href="#implementing-raw-block-volume-support" id="implementing-raw-block-volume-support"><h2>Implementing Raw Block Volume Support</h2></a>
<ul>
<li>TODO: detail how to expose raw block volume support in CSI Driver.</li>
<li>TODO: explain how raw block differs from mounted (file)</li>
<li>TODO: answer: can a CSI driver choose to implement only raw block and not mounted (file)?</li>
<li>TODO: detail the level of raw block volume functionality the CSI Sidecar containers currently provide.</li>
<li>TODO: detail how Kubernetes API raw block fields get mapped to CSI methods/fields.</li>
</ul>
<a class="header" href="#skip-kubernetes-attach-and-detach" id="skip-kubernetes-attach-and-detach"><h1>Skip Kubernetes Attach and Detach</h1></a>
<p><strong>Status:</strong> Alpha</p>
<a class="header" href="#problem" id="problem"><h1>Problem</h1></a>
<p>Volume drivers, like NFS, for example, have no concept of an attach (<code>ControllerPublishVolume</code>). However, Kubernetes always executes <code>Attach</code> and <code>Detach</code> operations even if the CSI driver does not implement an attach operation (i.e. even if the CSI Driver does not implement a <code>ControllerPublishVolume</code> call).</p>
<p>This was problematic because it meant <em>all</em> CSI drivers had to handle Kubernetes attachment. CSI Drivers that did not implement the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability could work around this by deploying an <a href="external-attacher.html">external-attacher</a> and the <code>external-attacher</code> would responds to Kubernetes attach operations and simply do a noop (because the CSI driver did not advertise the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability).</p>
<p>Although the workaround works, it adds an unnecessary operation (round-trip) in the preparation of a volume for a container, and requires CSI Drivers to deploy an unnecessary sidecar container (<code>external-attacher</code>).</p>
<a class="header" href="#skip-attach-with-csi-driver-object" id="skip-attach-with-csi-driver-object"><h1>Skip Attach with CSI Driver Object</h1></a>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>attachRequired</code> field instructs Kubernetes to skip any attach operation altogether.</p>
<p>For example, the existence of the following object would cause Kubernetes to skip attach operations for all CSI Driver <code>testcsidriver.example.com</code> volumes.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  attachRequired: false
</code></pre>
<p>The easiest way to use this feature is to deploy the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<a class="header" href="#pod-info-on-mount" id="pod-info-on-mount"><h1>Pod Info on Mount</h1></a>
<p><strong>Status:</strong> Alpha</p>
<a class="header" href="#problem-1" id="problem-1"><h1>Problem</h1></a>
<p>CSI avoids encoding Kubernetes specific information in to the specification, since it aims to support multiple orchestration systems (beyond just Kubernetes).</p>
<p>This can be problematic because some CSI drivers require information about the workload (e.g. which pod is referencing this volume), and CSI does not provide this information natively to drivers.</p>
<a class="header" href="#pod-info-on-mount-with-csi-driver-object" id="pod-info-on-mount-with-csi-driver-object"><h1>Pod Info on Mount with CSI Driver Object</h1></a>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>podInfoOnMountVersion</code> field instructs Kubernetes that the CSI driver requires additional pod information (like podName, podUID, etc.) during mount operations.</p>
<p>For example, the existence of the following object would cause Kubernetes to add pod information at mount time to the <code>NodePublishVolumeRequest.volume_context</code> map.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMountVersion: v1
</code></pre>
<p>There is only one <code>podInfoOnMountVersion</code> version currently supported: <code>v1</code>.</p>
<p>The value <code>v1</code> for <code>podInfoOnMountVersion</code> will result in the following key/values being added to <code>publish_context</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/pod.name: {pod.Name}</code></li>
<li><code>csi.storage.k8s.io/pod.namespace: {pod.Namespace}</code></li>
<li><code>csi.storage.k8s.io/pod.uid: {pod.UID}</code></li>
</ul>
<p>The easiest way to use this feature is to deploy the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<a class="header" href="#ephemeral-local-volumes" id="ephemeral-local-volumes"><h1>Ephemeral Local Volumes</h1></a>
<blockquote>
<a class="header" href="#this-page-is-still-under-active-development-2" id="this-page-is-still-under-active-development-2"><h2><em>This page is still under active development.</em></h2></a>
</blockquote>
<p><strong>Status:</strong> Alpha</p>
<p>Kubernetes supports three types of volumes:</p>
<ol>
<li>Remote Persistent Volumes</li>
<li>Local Persistent Volumes</li>
<li>Local Ephemeral Volumes</li>
</ol>
<p>The initial focus of Kubernetes CSI was Remote Persistent Volumes. However, the goal is for CSI to support all three types.</p>
<p>This page documents how to create &quot;Local Ephemeral Volumes&quot; for Kubernetes using CSI.</p>
<a class="header" href="#what-is-a-local-ephemeral-volumes" id="what-is-a-local-ephemeral-volumes"><h1>What is a Local Ephemeral Volumes?</h1></a>
<p>A Local Ephemeral Volumes is a volume whose lifecycle is tied to the lifecycle of a single pod:</p>
<ul>
<li>The volume is &quot;provisioned&quot; (either empty or with some pre-populated data) when the pod is created.</li>
<li>The volume is deleted when the pod is terminated.</li>
</ul>
<p><a href="https://kubernetes.io/docs/concepts/storage/volumes/#secret">Kubernetes Secret Volumes</a> are a good example (non-CSI) of a local ephemeral volumes.</p>
<a class="header" href="#how-to-write-a-csi-driver-for-local-ephemeral-volumes" id="how-to-write-a-csi-driver-for-local-ephemeral-volumes"><h1>How to write a CSI Driver for Local Ephemeral Volumes</h1></a>
<p>The following features make it easier to develop CSI Drivers that expose local ephemeral volumes:</p>
<ul>
<li><a href="pod-info.html">Pod Info on Mount</a>
<ul>
<li>This feature provides the CSI driver pod information at mount time. Many ephemeral volumes write some files at mount time. Often the data they write depends on the the pod they are operating on.</li>
</ul>
</li>
<li><a href="skip-attach.html">Skip Attach</a>
<ul>
<li>This instructs Kubernetes to skip any attach operation (<code>ControllerPublishVolume</code>) altogether. Local ephemeral volume drivers generally do not have or need a cluster control plane component.</li>
</ul>
</li>
</ul>
<p>Features currently in development to improve Local Ephemeral Volume support:</p>
<ul>
<li>Inline Volume Support
<ul>
<li>Having to create a PV and a PVC for every ephemeral volume is onerous. Being able to specify a volume inside a pod definition (not currently possible for CSI drivers) will make that easier.</li>
</ul>
</li>
</ul>
<a class="header" href="#deploying-csi-driver-on-kubernetes" id="deploying-csi-driver-on-kubernetes"><h1>Deploying CSI Driver on Kubernetes</h1></a>
<blockquote>
<a class="header" href="#this-page-is-out-of-date-and-under-active-development" id="this-page-is-out-of-date-and-under-active-development"><h2><em>This page is out-of-date and under active development.</em></h2></a>
</blockquote>
<p>This page describes to CSI driver developers how to deploy their driver onto a Kubernetes cluster.</p>
<a class="header" href="#overview" id="overview"><h2>Overview</h2></a>
<p>There are three components plus the kubelet that enable CSI drivers to provide storage to Kubernetes. These components are sidecar containers which are responsible for communication with both Kubernetes and the CSI driver, making the appropriate CSI calls for their respectful Kubernetes events.</p>
<a class="header" href="#sidecar-containers" id="sidecar-containers"><h2>Sidecar Containers</h2></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1JExJ_98dt0NAsJ7iI0_9loeTn2rbLeEcpOMEvKrF-9w/edit?usp=sharing"><img src="images/sidecar-container.png" alt="sidecar-container" /></a></p>
<p>Sidecar containers manage Kubernetes events and make the appropriate calls to the CSI driver. These are the <em>external attacher</em>, <em>external provisioner</em>, <em>external snapshotter</em> and the <em>driver registrar</em>.</p>
<a class="header" href="#external-attacher" id="external-attacher"><h3>External Attacher</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-attacher">external-attacher</a> is a sidecar container that watches Kubernetes <em>VolumeAttachment</em> objects and triggers CSI <em>ControllerPublish</em> and <em>ControllerUnpublish</em> operations against a driver endpoint. As of this writing, the external attacher does not support leader election and therefore there can be only one running per CSI driver.  For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#attaching-and-detaching"><em>Attaching and Detaching</em></a>.</p>
<p>Note, even though this is called the <em>external attacher</em>, its function is to call the CSI API calls <em>ControllerPublish</em> and <em>ControllerUnpublish</em>. These calls most likely will occur in a node which is <em>not</em> the one that will mount the volume. For this reason, many CSI drivers do not support these calls, instead doing the attach/detach and mount/unmount both in the CSI <em>NodePublish</em> and <em>NodeUnpublish</em> calls done by the kubelet at the node which is supposed to mount.</p>
<a class="header" href="#external-provisioner" id="external-provisioner"><h3>External Provisioner</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-provisioner">external-provisioner</a> is a Sidecar container that watches Kubernetes <em>PersistentVolumeClaim</em> objects and triggers CSI <em>CreateVolume</em> and <em>DeleteVolume</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#provisioning-and-deleting"><em>Provisioning and Deleting</em></a>.</p>
<a class="header" href="#external-snapshotter" id="external-snapshotter"><h3>External Snapshotter</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-snapshotter">external-snapshotter</a> is a Sidecar container that watches Kubernetes <em>VolumeSnapshot</em> objects and triggers CSI <em>CreateSnapshot</em> and <em>DeleteSnapshot</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-snapshot.md"><em>Snapshot Design Proposal</em></a>.</p>
<a class="header" href="#driver-registrar" id="driver-registrar"><h3>Driver Registrar</h3></a>
<p><a href="https://github.com/kubernetes-csi/driver-registrar">driver-registrar</a> is a sidecar container that registers the CSI driver with kubelet, and adds the drivers custom NodeId to a label on the Kubernetes Node API Object. It does this by communicating with the <em>Identity</em> service on the CSI driver and also calling the CSI <em>GetNodeId</em> operation. The driver registrar must have the Kubernetes name for the node set through the environment variable <code>KUBE_NODE_NAME</code> as follows:</p>
<pre><code class="language-yaml">        - name: csi-driver-registrar
          imagePullPolicy: Always
          image: quay.io/k8scsi/driver-registrar:v0.2.0
          args:
            - &quot;--v=5&quot;
            - &quot;--csi-address=$(ADDRESS)&quot;
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          volumeMounts:
            - name: socket-dir
              mountPath: /csi
</code></pre>
<a class="header" href="#kubelet" id="kubelet"><h3>Kubelet</h3></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1NXaVNDh3mSDhog7Q3Y9eELyEF24F8Z-Kk0ujR3pyOes/edit?usp=sharing"><img src="images/kubelet.png" alt="kubelet" /></a></p>
<p>The Kubernetes kubelet runs on every node and is responsible for making the CSI calls <em>NodePublish</em> and <em>NodeUnpublish</em>. These calls mount and unmount the storage volume from the storage system, making it available to the Pod to consume. As shown in the <em>external-attacher</em>, most CSI drivers choose to implement both their attach/detach and mount/unmount calls in the <em>NodePublish</em> and <em>NodeUnpublish</em> calls. They do this because the kubelet makes the request on the node which is to consume the volume.</p>
<a class="header" href="#mount-point" id="mount-point"><h3>Mount point</h3></a>
<p>The mount point used by the CSI driver must be set to <em>Bidirectional</em>. See the example below:</p>
<pre><code class="language-yaml">          volumeMounts:
            - name: socket-dir
              mountPath: /csi
            - name: mountpoint-dir
              mountPath: /var/lib/kubelet/pods
              mountPropagation: &quot;Bidirectional&quot;
      volumes:
        - name: socket-dir
          hostPath:
            path: /var/lib/kubelet/plugins/csi-hostpath
            type: DirectoryOrCreate
        - name: mountpoint-dir
          hostPath:
            path: /var/lib/kubelet/pods
            type: Directory
</code></pre>
<a class="header" href="#rbac-rules" id="rbac-rules"><h3>RBAC Rules</h3></a>
<p>Side car containers need the appropriate permissions to be able to access and manipulate Kubernetes objects. Here are the RBAC rules needed:</p>
<pre><code class="language-yaml">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-hostpath-role
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumes&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumeclaims&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;nodes&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;storageclasses&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;volumeattachments&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
</code></pre>
<a class="header" href="#deploying" id="deploying"><h2>Deploying</h2></a>
<p>Deploying a CSI driver onto Kubernetes is highlighted in detail in <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes"><em>Recommended Mechanism for Deploying CSI Drivers on Kubernetes</em></a>.</p>
<a class="header" href="#enable-privileged-pods" id="enable-privileged-pods"><h2>Enable privileged Pods</h2></a>
<p>To use CSI drivers, your Kubernetes cluster must allow privileged pods (i.e. <code>--allow-privileged</code> flag must be set to <code>true</code> for both the API server and the kubelet). This is the default in some environments (e.g. GCE, GKE, <code>kubeadm</code>).</p>
<p>Ensure your API server are started with the privileged flag:</p>
<pre><code class="language-shell">$ ./kube-apiserver ...  --allow-privileged=true ...
</code></pre>
<pre><code class="language-shell">$ ./kubelet ...  --allow-privileged=true ...
</code></pre>
<blockquote>
<p>Note: Starting from Kubernetes 1.13.0, --allow-privileged is true for kubelet. It'll be deprecated in future kubernetes releases.</p>
</blockquote>
<a class="header" href="#enabling-mount-propagation" id="enabling-mount-propagation"><h2>Enabling mount propagation</h2></a>
<p>Another feature that CSI depends on is mount propagation.  It allows the sharing of volumes mounted by one container with other containers in the same pod, or even to other pods on the same node.  For mount propagation to work, the Docker daemon for the cluster must allow shared mounts. See the [mount propagation docs][mount-propagation-docs] to find out how to enable this feature for your cluster.  [This page][docker-shared-mount] explains how to check if shared mounts are enabled and how to configure Docker for shared mounts.</p>
<a class="header" href="#examples-1" id="examples-1"><h3>Examples</h3></a>
<ul>
<li>Simple deployment example using a single pod for all components: see the <a href="Example.html">hostpath example</a>.</li>
<li>Full deployment example using a <em>DaemonSet</em> for the node plugin and <em>StatefulSet</em> for the controller plugin: check the <a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs/deploy/kubernetes">NFS driver deployment files</a>.</li>
</ul>
<a class="header" href="#more-information" id="more-information"><h2>More information</h2></a>
<p>For more information, please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md"><em>CSI Volume Plugins in Kubernetes Design Doc</em></a>.</p>
<a class="header" href="#example" id="example"><h1>Example</h1></a>
<blockquote>
<a class="header" href="#this-page-is-out-of-date-and-under-active-development-1" id="this-page-is-out-of-date-and-under-active-development-1"><h2><em>This page is out-of-date and under active development.</em></h2></a>
</blockquote>
<p>The
<a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a>
can be used to provision local storage in a single node test. This
section shows how to deploy and use that driver in Kubernetes.</p>
<p>The deployment of a CSI driver determines which RBAC rules are
needed. For example, enabling or disabling leadership election changes
which permissions the external-attacher and external-provisioner need.
This example deployment uses the original RBAC rule files that are
maintained together with those sidecar apps and deploys into the
default namespace.</p>
<p>A real production should copy the RBAC files and customize them as
explained in the comments of those files.</p>
<a class="header" href="#deployment-6" id="deployment-6"><h2>Deployment</h2></a>
<p>This was initially tested with Kubernetes v1.12 and should still work
there. It was also tested with a 1.13 pre-release snapshot. To ensure
that all necessary features are enabled, set the following feature
gate flags to true:</p>
<pre><code>--feature-gates=CSIPersistentVolume=true,MountPropagation=true,VolumeSnapshotDataSource=true,KubeletPluginsWatcher=true,CSINodeInfo=true,CSIDriverRegistry=true
</code></pre>
<p><code>CSIPersistentVolume</code> is enabled by default in v1.10. <code>MountPropagation</code> is enabled by default
in v1.10. <code>VolumeSnapshotDataSource</code> is a new alpha feature in v1.12. <code>KubeletPluginsWatcher</code>
is enabled by default in v1.12. <code>CSINodeInfo</code> and <code>CSIDriverRegistry</code> are new alpha features
in v1.12.</p>
<p>CRDs need to be created manually for <code>CSIDriverRegistry</code> and <code>CSINodeInfo</code>:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/csi-api/blob/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csidriver.yaml">https://raw.githubusercontent.com/kubernetes/csi-api/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csidriver.yaml</a> --validate=false
<code>customresourcedefinition.apiextensions.k8s.io/csidrivers.csi.storage.k8s.io created</code></p>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/csi-api/blob/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csinodeinfo.yaml">https://raw.githubusercontent.com/kubernetes/csi-api/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csinodeinfo.yaml</a> --validate=false
<code>customresourcedefinition.apiextensions.k8s.io/csinodeinfos.csi.storage.k8s.io created</code></p>
</blockquote>
<a class="header" href="#create-rbac-rules-for-csi-provisioner" id="create-rbac-rules-for-csi-provisioner"><h3>Create RBAC rules for CSI provisioner</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/external-provisioner/blob/1cd1c20a6d4b2fcd25c98a008385b436d61d46a4/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/external-provisioner/1cd1c20a6d4b2fcd25c98a008385b436d61d46a4/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>clusterrole.rbac.authorization.k8s.io/external-provisioner-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-provisioner-role created
role.rbac.authorization.k8s.io/external-provisioner-cfg created
rolebinding.rbac.authorization.k8s.io/csi-provisioner-role-cfg created
</code></pre>
</blockquote>
<a class="header" href="#create-rbac-rules-for-csi-attacher" id="create-rbac-rules-for-csi-attacher"><h3>Create RBAC rules for CSI attacher</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/external-attacher/blob/9da8c6d20d58750ee33d61d0faf0946641f50770/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/external-attacher/9da8c6d20d58750ee33d61d0faf0946641f50770/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>serviceaccount/csi-attacher created
clusterrole.rbac.authorization.k8s.io/external-attacher-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-attacher-role created
role.rbac.authorization.k8s.io/external-attacher-cfg created
rolebinding.rbac.authorization.k8s.io/csi-attacher-role-cfg created
</code></pre>
</blockquote>
<a class="header" href="#create-rbac-rules-for-node-plugin" id="create-rbac-rules-for-node-plugin"><h3>Create RBAC rules for node plugin</h3></a>
<p>Only the <code>driver-registrar</code> interacts directly with Kubernetes, so it's those RBAC rules that are needed:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/driver-registrar/blob/87d0059110a8b4a90a6d2b5a8702dd7f3f270b80/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/driver-registrar/87d0059110a8b4a90a6d2b5a8702dd7f3f270b80/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>serviceaccount/csi-driver-registrar created
clusterrole.rbac.authorization.k8s.io/driver-registrar-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-driver-registrar-role created
</code></pre>
</blockquote>
<a class="header" href="#create-rbac-rules-for-csi-snapshotter" id="create-rbac-rules-for-csi-snapshotter"><h3>Create RBAC rules for CSI snapshotter</h3></a>
<p>The CSI snapshotter is an optional sidecar container. You only need to create these
RBAC rules if you want to test the snapshot feature.</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/01bd7f356e6718dee87914232d287631655bef1d/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/01bd7f356e6718dee87914232d287631655bef1d/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>serviceaccount/csi-snapshotter created
clusterrole.rbac.authorization.k8s.io/external-snapshotter-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-snapshotter-role created
</code></pre>
</blockquote>
<a class="header" href="#deploy-driver-registrar-and-hostpath-csi-plugin-in-daemonset-pod" id="deploy-driver-registrar-and-hostpath-csi-plugin-in-daemonset-pod"><h3>Deploy driver-registrar and hostpath CSI plugin in DaemonSet pod</h3></a>
<p>The CSI sidecar apps are going to connect to the CSI driver, therefore
starting it first helps avoid timeouts and intermittent container
restarts:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/kubernetes/blob/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpathplugin.yaml">https://raw.githubusercontent.com/kubernetes/kubernetes/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpathplugin.yaml</a>
<code>daemonset.apps/csi-hostpathplugin created</code></p>
<p>$ kubectl get pod</p>
<pre><code>NAME                       READY   STATUS    RESTARTS   AGE
csi-hostpathplugin-4k7hk   2/2     Running   0          22s
</code></pre>
</blockquote>
<a class="header" href="#deploy-csi-provisioner-in-statefulset-pod" id="deploy-csi-provisioner-in-statefulset-pod"><h3>Deploy CSI provisioner in StatefulSet pod</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/kubernetes/blob/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-provisioner.yaml">https://raw.githubusercontent.com/kubernetes/kubernetes/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-provisioner.yaml</a></p>
<pre><code>service/csi-hostpath-provisioner created
statefulset.apps/csi-hostpath-provisioner created
</code></pre>
<p>$ kubectl get pod</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-provisioner-0   1/1     Running   0          14s
csi-hostpathplugin-4k7hk     2/2     Running   0          75s
</code></pre>
</blockquote>
<a class="header" href="#deploy-csi-attacher-in-statefulset-pod" id="deploy-csi-attacher-in-statefulset-pod"><h3>Deploy CSI attacher in StatefulSet pod</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/kubernetes/blob/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-attacher.yaml">https://raw.githubusercontent.com/kubernetes/kubernetes/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-attacher.yaml</a></p>
<pre><code>service/csi-hostpath-attacher created
statefulset.apps/csi-hostpath-attacher created
</code></pre>
<p>$ kubectl get pod</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-attacher-0      1/1     Running   0          14s
csi-hostpath-provisioner-0   1/1     Running   0          56s
csi-hostpathplugin-4k7hk     2/2     Running   0          117s
</code></pre>
</blockquote>
<a class="header" href="#deploy-livenessprobe-with-csi-plugin" id="deploy-livenessprobe-with-csi-plugin"><h3>Deploy livenessprobe with CSI plugin</h3></a>
<p>The CSI community provides a livenessprobe side-container that can be integrated with the CSI driver services (Node and Controller) to provide the liveness of the CSI service containers.</p>
<p>The livenessprobe side-container will expose the an http endpoint that will be used in a kubernetes liveness probe.</p>
<p>Below is an example configuration which needs to be added to CSI driver services (Node and Controller) yamls:</p>
<p>Note: This example is derived from <a href="https://github.com/kubernetes-csi/livenessprobe#using-livenessprobe">using-livenessprobe</a> from <a href="https://github.com/kubernetes-csi/livenessprobe">kubernetes-csi/livenessprobe</a></p>
<pre><code class="language-yaml">- name: hostpath-driver
    image: quay.io/k8scsi/hostpathplugin:vx.x.x
    imagePullPolicy: Always
    securityContext:
      privileged: true
#
# Defining port which will be used to GET plugin health status
# 9808 is default, but can be changed.
#
    ports:
    - containerPort: 9808
      name: healthz
      protocol: TCP
    livenessProbe:
      failureThreshold: 5
      httpGet:
        path: /healthz
        port: healthz
      initialDelaySeconds: 10
      timeoutSeconds: 3
      periodSeconds: 2
      failureThreshold: 1
...
#
# Spec for liveness probe sidecar container
# 
 - name: liveness-probe
    imagePullPolicy: Always
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
    image: quay.io/k8scsi/livenessprobe:v0.4.1
    args:
    - --csi-address=/csi/csi.sock
    - --connection-timeout=3s
    - --health-port=9898
#
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>--csi-address</code> - specifies the Unix domain socket path, as seen in the container, for the CSI driver. It allows the livenessprobe sidecar to communicate with the driver for driver liveness information.  Mount path <code>/csi</code> is mapped to HostPath entry <code>socket-dir</code> which is mapped to directory <code>/var/lib/kubelet/plugins/csi-hostpath</code></p>
</li>
<li>
<p><code>--connection-timeout</code> - specifies the timeout duration of waiting for CSI driver socket in seconds. (default 30s)</p>
</li>
<li>
<p><code>--health-port</code> - specifies the TCP ports for listening healthz requests (default &quot;9808&quot;)</p>
</li>
</ul>
<a class="header" href="#deploy-csi-snapshotter-in-statefulset-pod" id="deploy-csi-snapshotter-in-statefulset-pod"><h3>Deploy CSI snapshotter in StatefulSet pod</h3></a>
<p>The CSI snapshotter is an optional sidecar container. You only need to deploy it if you
want to test the snapshot feature.</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-hostpath-snapshotter.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-hostpath-snapshotter.yaml</a></p>
<pre><code>service/csi-hostpath-snapshotter created
statefulset.apps/csi-hostpath-snapshotter created
</code></pre>
<p>$ kubectl get pod</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-attacher-0      1/1     Running   0          58s
csi-hostpath-provisioner-0   1/1     Running   0          100s
csi-hostpath-snapshotter-0   1/1     Running   0          12s
csi-hostpathplugin-4k7hk     2/2     Running   0          2m41s
</code></pre>
</blockquote>
<a class="header" href="#usage-8" id="usage-8"><h2>Usage</h2></a>
<p>Dynamic provisioning is enabled by creating a <code>csi-hostpath-sc</code> storage class.</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-storageclass.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-storageclass.yaml</a>
<code>storageclass.storage.k8s.io/csi-hostpath-sc created</code></p>
</blockquote>
<p>We can use this storage class to create and claim a new volume:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-pvc.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-pvc.yaml</a>
<code>persistentvolumeclaim/csi-pvc created</code></p>
<p>$ kubectl get pvc</p>
<pre><code>NAME      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE
csi-pvc   Bound    pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            csi-hostpath-sc   3s
</code></pre>
<p>$ kubectl get pv</p>
<pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             STORAGECLASS      REASON   AGE
pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            Delete           Bound    default/csi-pvc   csi-hostpath-sc            3s
</code></pre>
</blockquote>
<p>The HostPath driver is configured to create new volumes under <code>/tmp</code> inside
the <code>hostpath</code> container in the CSI hostpath plugin DaemonSet pod and thus
persist as long as the DaemonSet pod itself.
We can use such volumes in another pod like this:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-app.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-app.yaml</a>
<code>pod/my-csi-app created</code></p>
<p>$ kubectl get pods</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-attacher-0      1/1     Running   0          117s
csi-hostpath-provisioner-0   1/1     Running   0          2m39s
csi-hostpath-snapshotter-0   1/1     Running   0          71s
csi-hostpathplugin-4k7hk     2/2     Running   0          3m40s
my-csi-app                   1/1     Running   0          14s
</code></pre>
<p>$ kubectl describe pods/my-csi-app</p>
<pre><code>Name:               my-csi-app
Namespace:          default
Priority:           0
PriorityClassName:  &lt;none&gt;
Node:               127.0.0.1/127.0.0.1
Start Time:         Wed, 03 Oct 2018 06:59:19 -0700
Labels:             &lt;none&gt;
Annotations:        &lt;none&gt;
Status:             Running
IP:                 172.17.0.5
Containers:
  my-frontend:
    Container ID:  docker://fd2950af39a155bdf08d1da341cfb23aa0d1af3eaaad6950a946355789606e8c
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:2a03a6059f21e150ae84b0973863609494aad70f0a80eaeb64bddd8d92465812
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sleep
      1000000
    State:          Running
      Started:      Wed, 03 Oct 2018 06:59:22 -0700
    Ready:          True
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /data from my-csi-volume (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-xms2g (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  my-csi-volume:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  csi-pvc
    ReadOnly:   false
  default-token-xms2g:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-xms2g
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &lt;none&gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason                  Age   From                     Message
  ----    ------                  ----  ----                     -------
  Normal  Scheduled               69s   default-scheduler        Successfully assigned default/my-csi-app to 127.0.0.1
  Normal  SuccessfulAttachVolume  69s   attachdetach-controller  AttachVolume.Attach succeeded for volume &quot;pvc-0571cc14-c714-11e8-8911-000c2967769a&quot;
  Normal  Pulling                 67s   kubelet, 127.0.0.1       pulling image &quot;busybox&quot;
  Normal  Pulled                  67s   kubelet, 127.0.0.1       Successfully pulled image &quot;busybox&quot;
  Normal  Created                 67s   kubelet, 127.0.0.1       Created container
  Normal  Started                 66s   kubelet, 127.0.0.1       Started container
</code></pre>
</blockquote>
<a class="header" href="#confirming-the-setup" id="confirming-the-setup"><h2>Confirming the setup</h2></a>
<p>Writing inside the app container should be visible in <code>/tmp</code> of the <code>hostpath</code> container:</p>
<pre><code>$ kubectl exec -it my-csi-app /bin/sh
/ # touch /data/hello-world
/ # exit

$ kubectl exec -it $(kubectl get pods --selector app=csi-hostpathplugin -o jsonpath='{.items[*].metadata.name}') -c hostpath /bin/sh
/ # find / -name hello-world
/tmp/057485ab-c714-11e8-bb16-000c2967769a/hello-world
/ # exit
</code></pre>
<p>There should be a <code>VolumeAttachment</code> while the app has the volume mounted:</p>
<blockquote>
<p>$ kubectl get VolumeAttachment</p>
<pre><code>Name:         csi-a4e97f3af2161c6d081b8e96c58ed00c9bf1e1745e89b2545e24505437f015df
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  storage.k8s.io/v1beta1
Kind:         VolumeAttachment
Metadata:
  Creation Timestamp:  2018-10-03T13:59:19Z
  Resource Version:    1730
  Self Link:           /apis/storage.k8s.io/v1beta1/volumeattachments/csi-a4e97f3af2161c6d081b8e96c58ed00c9bf1e1745e89b2545e24505437f015df
  UID:                 862d7241-c714-11e8-8911-000c2967769a
Spec:
  Attacher:   csi-hostpath
  Node Name:  127.0.0.1
  Source:
    Persistent Volume Name:  pvc-0571cc14-c714-11e8-8911-000c2967769a
Status:
  Attached:  true
Events:      &lt;none&gt;
</code></pre>
</blockquote>
<a class="header" href="#snapshot-support" id="snapshot-support"><h2>Snapshot support</h2></a>
<p>Enable dynamic provisioning of volume snapshot by creating a volume snapshot
class as follows:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshotclass.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshotclass.yaml</a>
<code>volumesnapshotclass.snapshot.storage.k8s.io/csi-hostpath-snapclass created</code></p>
<p>$ kubectl get volumesnapshotclass</p>
<pre><code>NAME                     AGE
csi-hostpath-snapclass   11s
</code></pre>
<p>$ kubectl describe volumesnapshotclass</p>
<pre><code>Name:         csi-hostpath-snapclass
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  snapshot.storage.k8s.io/v1alpha1
Kind:         VolumeSnapshotClass
Metadata:
  Creation Timestamp:  2018-10-03T14:15:30Z
  Generation:          1
  Resource Version:    2418
  Self Link:           /apis/snapshot.storage.k8s.io/v1alpha1/volumesnapshotclasses/csi-hostpath-snapclass
  UID:                 c8f5bc47-c716-11e8-8911-000c2967769a
Snapshotter:           csi-hostpath
Events:                &lt;none&gt;
</code></pre>
</blockquote>
<p>Use the volume snapshot class to dynamically create a volume snapshot:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshot.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshot.yaml</a>
<code>volumesnapshot.snapshot.storage.k8s.io/new-snapshot-demo created</code></p>
<p>$ kubectl get volumesnapshot</p>
<pre><code>NAME                AGE
new-snapshot-demo   12s
</code></pre>
<p>$ kubectl get volumesnapshotcontent</p>
<pre><code>NAME                                               AGE
snapcontent-f55db632-c716-11e8-8911-000c2967769a   14s
</code></pre>
<p>$ kubectl describe volumesnapshot</p>
<pre><code>Name:         new-snapshot-demo
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  snapshot.storage.k8s.io/v1alpha1
Kind:         VolumeSnapshot
Metadata:
  Creation Timestamp:  2018-10-03T14:16:45Z
  Generation:          1
  Resource Version:    2476
  Self Link:           /apis/snapshot.storage.k8s.io/v1alpha1/namespaces/default/volumesnapshots/new-snapshot-demo
  UID:                 f55db632-c716-11e8-8911-000c2967769a
Spec:
  Snapshot Class Name:    csi-hostpath-snapclass
  Snapshot Content Name:  snapcontent-f55db632-c716-11e8-8911-000c2967769a
  Source:
    Kind:  PersistentVolumeClaim
    Name:  csi-pvc
Status:
  Creation Time:  2018-10-03T14:16:45Z
  Ready:          true
  Restore Size:   1Gi
Events:           &lt;none&gt;
</code></pre>
<p>$ kubectl describe volumesnapshotcontent</p>
<pre><code>Name:         snapcontent-f55db632-c716-11e8-8911-000c2967769a
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  snapshot.storage.k8s.io/v1alpha1
Kind:         VolumeSnapshotContent
Metadata:
  Creation Timestamp:  2018-10-03T14:16:45Z
  Generation:          1
  Resource Version:    2474
  Self Link:           /apis/snapshot.storage.k8s.io/v1alpha1/volumesnapshotcontents/snapcontent-f55db632-c716-11e8-8911-000c2967769a
  UID:                 f561411f-c716-11e8-8911-000c2967769a
Spec:
  Csi Volume Snapshot Source:
    Creation Time:    1538576205471577525
    Driver:           csi-hostpath
    Restore Size:     1073741824
    Snapshot Handle:  f55ff979-c716-11e8-bb16-000c2967769a
  Persistent Volume Ref:
    API Version:        v1
    Kind:               PersistentVolume
    Name:               pvc-0571cc14-c714-11e8-8911-000c2967769a
    Resource Version:   1573
    UID:                0575b966-c714-11e8-8911-000c2967769a
  Snapshot Class Name:  csi-hostpath-snapclass
  Volume Snapshot Ref:
    API Version:       snapshot.storage.k8s.io/v1alpha1
    Kind:              VolumeSnapshot
    Name:              new-snapshot-demo
    Namespace:         default
    Resource Version:  2472
    UID:               f55db632-c716-11e8-8911-000c2967769a
Events:                &lt;none&gt;
</code></pre>
</blockquote>
<a class="header" href="#restore-volume-from-snapshot-support" id="restore-volume-from-snapshot-support"><h2>Restore volume from snapshot support</h2></a>
<p>Follow the following example to create a volume from a volume snapshot:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-restore.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-restore.yaml</a>
<code>persistentvolumeclaim/hpvc-restore created</code></p>
<p>$ kubectl get pvc</p>
<pre><code>NAME           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE
csi-pvc        Bound    pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            csi-hostpath-sc   24m
hpvc-restore   Bound    pvc-77324684-c717-11e8-8911-000c2967769a   1Gi        RWO            csi-hostpath-sc   6s
</code></pre>
<p>$ kubectl get pv</p>
<pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                  STORAGECLASS      REASON   AGE
pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            Delete           Bound    default/csi-pvc        csi-hostpath-sc            25m
pvc-77324684-c717-11e8-8911-000c2967769a   1Gi        RWO            Delete           Bound    default/hpvc-restore   csi-hostpath-sc            33s
</code></pre>
</blockquote>
<p>If you encounter any problems, please check the <a href="Troubleshooting.html">Troubleshooting page</a>.</p>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>This section describes how CSI developers can test their CSI drivers.</p>
<ul>
<li><a href="unit-testing.html">Unit Testing</a></li>
<li><a href="functional-testing.html">Functional Testing</a></li>
</ul>
<a class="header" href="#unit-testing" id="unit-testing"><h1>Unit Testing</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity">CSI <code>sanity</code></a> package from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> can be used for unit testing your CSI driver.</p>
<p>It contains a set of basic tests that all CSI drivers should pass (for example, <code>NodePublishVolume should fail when no volume id is provided</code>, etc.).</p>
<p>This package can be used in two modes:</p>
<ul>
<li>Via a Golang test framework (<code>sanity</code> package is imported as a dependency)</li>
<li>Via a command line against your driver binary.</li>
</ul>
<p>Read the <a href="https://github.com/kubernetes-csi/csi-test/blob/master/pkg/sanity/README.md">documentation of the <code>sanity</code> package</a> for more details.</p>
<a class="header" href="#functional-testing" id="functional-testing"><h1>Functional Testing</h1></a>
<p>Some functional testing of your CSI driver can be done via the CLI mode of the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity">CSI <code>sanity</code></a> package.</p>
<p>Drivers should also be functionally &quot;end-to-end&quot; tested while deployed in a Kubernetes cluster. Currently how to do this and what tests to run is left up to driver authors. In the future, a project (currently in development) aims to enable use of a pre-built <code>kubernetes/e2e/e2e.test</code> binary containing a standard set of Kubernetes CSI end-to-end tests to be imported and run by third party CSI drivers. This documentation will be updated with more information once that is ready to use.</p>
<p>The CSI community is also looking in to establishing an official &quot;CSI Conformance Suite&quot; to recognize &quot;officially certified CSI drivers&quot;.  This documentation will be updated with more information once that process has been defined.</p>
<a class="header" href="#drivers" id="drivers"><h1>Drivers</h1></a>
<p>The following are a set of CSI driver which can be used with Kubernetes:</p>
<blockquote>
<p>NOTE: If you would like your driver to be added to this table, please open a pull request in <a href="https://github.com/kubernetes-csi/docs/pulls">this repo</a> updating this file.</p>
</blockquote>
<a class="header" href="#production-drivers" id="production-drivers"><h2>Production Drivers</h2></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud Elastic Block Storage</a> </td><td> v1.0.0 </td><td>A Container Storage Interface (CSI) Storage Plug-in for Alicloud Elastic Block Storage</td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud Elastic File System</a></td><td> v1.0.0 </td><td>A Container Storage Interface (CSI) Storage Plug-in for Alicloud Elastic File System</td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud OSS</a></td><td> v1.0.0 </td><td>A Container Storage Interface (CSI) Storage Plug-in for Alicloud OSS</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">AWS Elastic Block Storage</a> </td><td> v0.3.0 </td><td> A Container Storage Interface (CSI) Driver for AWS Elastic Block Storage (EBS)</td></tr>
<tr><td><a href="https://github.com/aws/aws-efs-csi-driver">AWS Elastic File System</a> </td><td> v0.1.0 </td><td> A Container Storage Interface (CSI) Driver for AWS Elastic File System (EFS)</td></tr>
<tr><td><a href="https://github.com/aws/aws-fsx-csi-driver">AWS FSx for Lustre</a> </td><td> v0.1.0 </td><td> A Container Storage Interface (CSI) Driver for AWS FSx for Lustre (EBS)</td></tr>
<tr><td><a href="https://github.com/andyzhangx/azuredisk-csi-driver">Azure disk</a></td><td> v0.1.0 (alpha) </td><td>A Container Storage Interface (CSI) Storage Plug-in for Azure disk</td></tr>
<tr><td><a href="https://github.com/andyzhangx/azurefile-csi-driver">Azure file</a></td><td> v0.1.0 (alpha) </td><td>A Container Storage Interface (CSI) Storage Plug-in for Azure file</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">CephFS</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for CephFS</td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for Cinder</td></tr>
<tr><td><a href="https://github.com/Datera/kubernetes-driver">Datera</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plugin for Datera Data Services Platform (DSP)</td></tr>
<tr><td><a href="https://github.com/digitalocean/csi-digitalocean">DigitalOcean Block Storage</a> </td><td> v0.4.0 </td><td> A Container Storage Interface (CSI) Driver for DigitalOcean Block Storage</td></tr>
<tr><td><a href="https://github.com/DriveScale/k8s-plugins">DriveScale</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for DriveScale software composable infrastructure solution</td></tr>
<tr><td><a href="https://ember-csi.io">Ember CSI</a> </td><td> v0.2.0 (alpha) </td><td> Multi-vendor CSI plugin supporting over 80 storage drivers to provide block and mount storage to Container Orchestration systems.</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a></td><td>Beta</td><td>A Container Storage Interface (CSI) Storage Plugin for Google Compute Engine Persistent Disk (GCE PD)</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-filestore-csi-driver">Google Cloud Filestore</a></td><td>Alpha</td><td>A Container Storage Interface (CSI) Storage Plugin for Google Cloud Filestore</td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Plugin for GlusterFS</td></tr>
<tr><td><a href="https://knowledge.hitachivantara.com/Documents/Adapters_and_Drivers/Storage_Adapters_and_Drivers/Containers">Hitachi Vantara</a> </td><td> v2.0 </td><td> A Container Storage Interface (CSI) Plugin for VSP series Storage</td></tr>
<tr><td><a href="https://github.com/linode/linode-blockstorage-csi-driver">Linode Block Storage</a> </td><td> v0.0.3 </td><td> A Container Storage Interface (CSI) Driver for Linode Block Storage</td></tr>
<tr><td><a href="https://github.com/LINBIT/linstor-csi">LINSTOR</a></td><td>v0.3.0</td><td>A Container Storage Interface (CSI) Storage Plugin for <a href="https://www.linbit.com/en/linstor/">LINSTOR</a></td></tr>
<tr><td><a href="https://github.com/mapr/mapr-csi">MapR</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Storage Plugin for MapR Data Platform</td></tr>
<tr><td><a href="https://github.com/moosefs/moosefs-csi">MooseFS</a></td><td>v0.0.1 (alpha)</td><td>A Container Storage Interface (CSI) Storage Plugin for <a href="https://moosefs.com/">MooseFS</a> clusters.</td></tr>
<tr><td><a href="https://github.com/NetApp/trident">NetApp</a> </td><td> v0.2.0 (alpha) </td><td> A Container Storage Interface (CSI) Storage Plug-in for NetApp's <a href="https://netapp-trident.readthedocs.io/">Trident</a> container storage orchestrator</td></tr>
<tr><td><a href="https://github.com/Nexenta/nexentastor-csi-driver">NexentaStor</a> </td><td> Beta </td><td> A Container Storage Interface (CSI) Driver for NexentaStor</td></tr>
<tr><td><a href="https://portal.nutanix.com/#/page/docs/details?targetId=CSI-Volume-Driver:CSI-Volume-Driver">Nutanix</a> </td><td> beta </td><td> A Container Storage Interface (CSI) Storage Driver for Nutanix</td></tr>
<tr><td><a href="https://www.opensds.io/">OpenSDS</a> </td><td> Beta </td><td> For more information, please visit <a href="https://github.com/opensds/nbp/releases">releases</a> and https://github.com/opensds/nbp/tree/master/csi</td></tr>
<tr><td><a href="https://portworx.com/">Portworx</a> </td><td> 0.3.0 </td><td> CSI implementation is available <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">here</a> which can be used as an example also.</td></tr>
<tr><td><a href="https://github.com/yunify/qingcloud-csi">QingCloud CSI</a> </td><td> v0.2.1 </td><td> A Container Storage Interface (CSI) Plugin for QingCloud Block Storage</td></tr>
<tr><td><a href="https://github.com/yunify/qingstor-csi">QingStor CSI</a> </td><td> v0.3.0 </td><td> A Container Storage Interface (CSI) Plugin for NeonSAN storage system</td></tr>
<tr><td><a href="https://github.com/quobyte/quobyte-csi">Quobyte</a> </td><td> v0.2.0 </td><td> A Container Storage Interface (CSI) Plugin for Quobyte</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">RBD</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage RBD Plug-in for Ceph</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-scaleio">ScaleIO</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plugin for DellEMC ScaleIO</td></tr>
<tr><td><a href="https://storageos.com/">StorageOS</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Plugin for StorageOS</td></tr>
<tr><td><a href="https://xsky-storage.github.io/xsky-csi-driver/">XSKY</a> </td><td> V1.1.2 </td><td> A Container Storage Interface (CSI) Driver for XSKY Distributed Block Storage (X-EBS)</td></tr>
<tr><td><a href="https://github.com/kubevault/csi-driver">Vault</a> </td><td> Alpha </td><td> A Container Storage Interface (CSI) Plugin for HashiCorp Vault</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vsphere">vSphere</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for VMware vSphere</td></tr>
<tr><td><a href="http://www.yanrongyun.com/">YanRongYun</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Driver for YanRong YRCloudFile Storage</td></tr>
</tbody></table>
<a class="header" href="#sample-drivers" id="sample-drivers"><h2>Sample Drivers</h2></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/flexadapter">Flexvolume</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a> </td><td> v0.2.0 </td><td> Only use for a single node tests. See the <a href="Example.html">Example</a> page for Kubernetes-specific instructions.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">In-memory Sample Mock Driver</a> </td><td> v0.3.0 </td><td> The sample mock driver used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs">NFS</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/jparklab/synology-csi">Synology NAS</a> </td><td> v1.0.0 </td><td> An unofficial (and unsupported) Container Storage Interface Driver for Synology NAS.</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vfs">VFS Driver</a> </td><td> Released </td><td> A CSI plugin that provides a virtual file system.</td></tr>
</tbody></table>
<a class="header" href="#troubleshooting" id="troubleshooting"><h1>Troubleshooting</h1></a>
<a class="header" href="#known-issues" id="known-issues"><h1>Known Issues</h1></a>
<ul>
<li>[<a href="https://github.com/kubernetes/minikube/issues/3378">minikube-3378</a>]: Volume mount causes minikube VM to become corrupted</li>
</ul>
<a class="header" href="#common-errors" id="common-errors"><h1>Common Errors</h1></a>
<a class="header" href="#node-plugin-pod-does-not-start-with-runcontainererror-status" id="node-plugin-pod-does-not-start-with-runcontainererror-status"><h3>Node plugin pod does not start with <em>RunContainerError</em> status</h3></a>
<p><code>kubectl describe pod your-nodeplugin-pod</code> shows:</p>
<pre><code>failed to start container &quot;your-driver&quot;: Error response from daemon:
linux mounts: Path /var/lib/kubelet/pods is mounted on / but it is not a shared mount
</code></pre>
<p>Your Docker host is not configured to allow shared mounts. Take a look at <a href="https://docs.portworx.com/knowledgebase/shared-mount-propagation.html">this page</a> for instructions to enable them.</p>
<a class="header" href="#external-attacher-cant-find-volumeattachments" id="external-attacher-cant-find-volumeattachments"><h3>External attacher can't find <em>VolumeAttachments</em></h3></a>
<p>If you have a Kubernetes 1.9 cluster, not being able to list <em>VolumeAttachment</em>
and the following error are due to the lack of the
<code>storage.k8s.io/v1alpha1=true</code> runtime configuration:</p>
<pre><code>$ kubectl logs csi-pod external-attacher
...
I0306 16:34:50.976069       1 reflector.go:240] Listing and watching *v1alpha1.VolumeAttachment from github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86

E0306 16:34:50.992034       1 reflector.go:205] github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86: Failed to list *v1alpha1.VolumeAttachment: the server could not find the requested resource
...
</code></pre>
<p>Please see the <a href="Kubernetes-1.9.html">Kubernetes 1.9</a> page.</p>
<a class="header" href="#problems-with-the-external-components" id="problems-with-the-external-components"><h3>Problems with the external components</h3></a>
<p>The external components images are under active development. It can
happen that they become incompatible with each other. If the
issues above above have been ruled out, <a href="https://github.com/kubernetes/community/tree/master/sig-storage">contact the sig-storage
team</a> and/or
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/e2e-tests.md#local-clusters">run the e2e test</a>:</p>
<pre><code>go run hack/e2e.go -- --provider=local --test --test_args=&quot;--ginkgo.focus=Feature:CSI&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
